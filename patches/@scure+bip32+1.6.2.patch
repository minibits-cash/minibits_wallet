diff --git a/node_modules/@scure/bip32/lib/esm/index.js b/node_modules/@scure/bip32/lib/esm/index.js
index ea306d0..c0ed23e 100644
--- a/node_modules/@scure/bip32/lib/esm/index.js
+++ b/node_modules/@scure/bip32/lib/esm/index.js
@@ -25,6 +25,8 @@ import { bytesToHex, concatBytes, createView, hexToBytes, utf8ToBytes } from '@n
 import { secp256k1 as secp } from '@noble/curves/secp256k1';
 import { mod } from '@noble/curves/abstract/modular';
 import { createBase58check } from '@scure/base';
+import quickCrypto from 'react-native-quick-crypto'
+
 const Point = secp.ProjectivePoint;
 const base58check = createBase58check(sha256);
 function bytesToNumber(bytes) {
@@ -89,7 +91,9 @@ export class HDKey {
             throw new Error('HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got ' +
                 seed.length);
         }
-        const I = hmac(sha512, MASTER_SECRET, seed);
+        // const I = hmac(sha512, MASTER_SECRET, seed);
+        console.log('[bip32.fromMasterSeed] Using ESM quickCrypto HMAC');        
+        const I = new Uint8Array(quickCrypto.createHmac('sha512', MASTER_SECRET).update(seed).digest());
         return new HDKey({
             versions,
             chainCode: I.slice(32),
@@ -206,7 +210,10 @@ export class HDKey {
             // Normal child: serP(point(kpar)) || ser32(index)
             data = concatBytes(this.pubKey, data);
         }
-        const I = hmac(sha512, this.chainCode, data);
+        // const I = hmac(sha512, this.chainCode, data);
+        console.log('[bip32.deriveChild] Using ESM quickCrypto HMAC');
+        const I = new Uint8Array(quickCrypto.createHmac('sha512', this.chainCode).update(data).digest())
+
         const childTweak = bytesToNumber(I.slice(0, 32));
         const chainCode = I.slice(32);
         if (!secp.utils.isValidPrivateKey(childTweak)) {
